# MVP y Roadmap de Desarrollo - SmashNotes

**Fecha:** 30 de Noviembre 2025, 16:42 hrs
**Tipo:** Estrategia de Producto

---

## Filosof√≠a de Desarrollo

Este proyecto sigue un enfoque **incremental y basado en datos reales**, evitando el sobredise√±o y permitiendo que la arquitectura evolucione con el conocimiento del dominio.

---

## Fase 1: MVP (Minimum Viable Product) - ACTUAL ‚úÖ

### Alcance
Implementar las funcionalidades core que permitan **empezar a recolectar datos inmediatamente**:

1. **Movimientos (Singles):**
   - Tabla `movimiento` con nombre, abreviatura
   - Registro simple de efectividad de un movimiento espec√≠fico

2. **True Combos:**
   - Tabla `combo` con nombre, abreviatura, descripci√≥n
   - Descripci√≥n en texto libre (ej: "DThrow ‚Üí UAir √ó 3")
   - Permite trackear % de √©xito sin complejidad

3. **Combos Variables (formato rudimentario):**
   - Mismo sistema que True Combos
   - Descripci√≥n incluye condiciones en texto natural
   - Ejemplo: "DThrow ‚Üí UAir √ó 3 (si DI malo) o Fair (si DI √≥ptimo)"
   - **No es perfecto, pero es funcional**

### Ventajas del MVP
- ‚úÖ **Funcional desde el d√≠a 1:** Puedes registrar datos de partidas reales inmediatamente
- ‚úÖ **Ciclo de aprendizaje r√°pido:** Descubrir√°s qu√© m√©tricas realmente importan
- ‚úÖ **Sin deuda t√©cnica cr√≠tica:** La estructura permite evoluci√≥n futura
- ‚úÖ **ROI inmediato:** Insights b√°sicos disponibles (% KO promedio, mejores setups, etc.)

### Queries de Ejemplo Posibles con MVP
```sql
-- ¬øQu√© combo de Mario tiene mejor % promedio de KO?
SELECT c.nombre, AVG(r.porcentaje_ko) AS promedio_ko
FROM registro r
JOIN ataque a ON r.id_ataque = a.id
JOIN combo c ON a.id_combo = c.id
WHERE a.tipo_ataque = 'combo'
GROUP BY c.nombre
ORDER BY promedio_ko DESC;

-- ¬øEn qu√© escenarios funciona mejor el UpAir de Fox?
SELECT e.nombre, AVG(r.porcentaje_ko) AS promedio
FROM registro r
JOIN ataque a ON r.id_ataque = a.id
JOIN movimiento m ON a.id_movimiento = m.id
JOIN escenario e ON r.id_escenario = e.id
WHERE m.nombre = 'Up Air'
GROUP BY e.nombre;
```

---

## Fase 2: An√°lisis B√°sico (3-6 meses) üìä

### Objetivo
Extraer **insights accionables** de los datos del MVP sin complejidad adicional.

### Actividades
1. **Dashboard de M√©tricas:**
   - Combos m√°s efectivos por personaje
   - Rangos de % √≥ptimos para cada setup
   - Escenarios con mejores/peores estad√≠sticas

2. **Descubrimiento de Patrones:**
   - "El DThrow de Mario funciona mejor entre 40-60%"
   - "El Knee de Falcon tiene 85% √©xito en Final Destination vs 70% en Battlefield"
   - "Los combos con propiedad 'Spike' tienen mejor consistencia en plataformas"

3. **Iteraci√≥n sobre el MVP:**
   - Agregar campos que descubras que faltan (ej: `peso_personaje_receptor`)
   - Refinar cat√°logos (`ataque_propiedad`, `posicion`)

### Salida de Esta Fase
- Conocimiento profundo de **qu√© variables afectan el √©xito de los combos**
- Lista clara de **qu√© condiciones vale la pena modelar** (DI, techs, etc.)
- Base de datos con cientos de registros para validar el modelo futuro

---

## Fase 3: Modelo de Grafos (Futuro - 12+ meses) üîÆ

### Cu√°ndo Implementar
**Solo cuando:**
- Tengas 500+ registros de combos variables
- Hayas identificado patrones recurrentes que justifiquen la complejidad
- Necesites responder preguntas como: "¬øQu√© rama del tech chase de Falcon es √≥ptima?"

### Implementaci√≥n
Crear las tablas:
- `combo_nodo`: Estados del combo (cada movimiento o situaci√≥n)
- `combo_transicion`: Aristas con condiciones (DI, techs, opciones del oponente)

### Ventajas del Grafo (a futuro)
1. **An√°lisis Probabil√≠stico:**
   - "La rama 'DI adentro' del Nair de Fox tiene 87% de √©xito vs 72% con DI afuera"
   
2. **Optimizaci√≥n de Rutas:**
   - "En este tech chase, cubrir Tech Roll Left + No Tech da cobertura de 80% con solo 2 opciones"

3. **Visualizaci√≥n Interactiva:**
   - Flowcharts clickeables que muestran % de √©xito de cada rama
   - Herramienta de pr√°ctica: "Qu√© hacer si el oponente hace X"

### Migraci√≥n desde MVP a Grafos
```sql
-- Paso 1: Agregar campo tipo_combo a la tabla existente
ALTER TABLE combo ADD COLUMN tipo_combo ENUM('true_combo', 'follow_up', 'tech_chase', '50_50') DEFAULT 'true_combo';

-- Paso 2: Crear tablas de grafos (sin tocar las existentes)
CREATE TABLE combo_nodo (...);
CREATE TABLE combo_transicion (...);

-- Paso 3: Migrar combos lineales (true combos) al modelo de grafos
-- Esto se hace con un script de migraci√≥n, no requiere borrar nada
```

**La clave:** Las tablas actuales (`movimiento`, `combo`) **nunca se borran**. Los grafos se agregan como una capa adicional de detalle.

---

## La Raz√≥n de Oro: Escalabilidad Sin Fricci√≥n üöÄ

### Observaci√≥n Clave
El dise√±o actual permite evolucionar sin romper nada:

1. **Ahora:** Insertas un combo llamado "Mario Ladder" con descripci√≥n "DThrow ‚Üí UAir √ó 3"
   - ‚úÖ Funciona perfectamente
   - ‚úÖ Empiezas a acumular datos

2. **Dentro de 6 meses:** Decides modelar ese combo como grafo
   - Creas nodos: `[DThrow] ‚Üí [UAir‚ÇÅ] ‚Üí [UAir‚ÇÇ] ‚Üí [UAir‚ÇÉ]`
   - Creas transiciones garantizadas entre cada nodo
   - El registro original de "Mario Ladder" **sigue funcionando**
   - La tabla `combo` tiene un FK opcional hacia `combo_nodo` (el nodo inicial del grafo)

3. **Dentro de 1 a√±o:** Tienes 50 combos modelados como grafos + 200 combos simples
   - Tus queries se adaptan: "Si tiene grafo, analiza por rama. Si no, usa el registro total."
   - **Todo coexiste armoniosamente**

### ¬øPor qu√© esto es incre√≠ble?
- **No hay "gran migraci√≥n"** que rompa todo
- **No hay "reescribir el backend"** cuando quieras grafos
- **No pierdes datos hist√≥ricos** al evolucionar el modelo
- **Puedes A/B test:** "¬øVale la pena modelar este combo como grafo o la descripci√≥n es suficiente?"

---

## Principios de Dise√±o

1. **Start Simple, Evolve Complex:**
   - Comienza con lo m√≠nimo que funciona
   - Agrega complejidad solo cuando la necesites (no "por si acaso")

2. **Data-Driven Decisions:**
   - Las decisiones de arquitectura se toman con **evidencia** de uso real
   - No adivines qu√© necesitar√°s; desc√∫brelo con datos

3. **Backward Compatibility:**
   - Cada cambio debe ser **aditivo**, no destructivo
   - Las tablas nuevas extienden, no reemplazan

4. **Premature Optimization is Evil:**
   - No implementes grafos si con texto resuelves el 90% de tus necesidades
   - El 10% restante puede esperar

---

## Checklist de Decisi√≥n: ¬øDebo Implementar Grafos?

Responde estas preguntas. Si tienes < 3 "S√≠", **NO** implementes grafos a√∫n:

- [ ] ¬øTengo m√°s de 500 registros de combos variables?
- [ ] ¬øNecesito distinguir % de √©xito entre diferentes rutas del mismo combo?
- [ ] ¬øLos usuarios me piden visualizar ramificaciones?
- [ ] ¬øTengo tiempo/recursos para construir un editor visual de grafos?
- [ ] ¬øYa identifiqu√© las 5-10 condiciones m√°s importantes (DI tipos, tech tipos)?

Si respondes "No" a la mayor√≠a: **Sigue con el MVP. Funciona perfectamente.**

---

## Conclusi√≥n

Este proyecto es un caso de estudio de **ingenier√≠a pragm√°tica**:
- Resuelve el problema de hoy con herramientas simples
- Dise√±a para permitir evoluci√≥n futura
- Deja que los **datos** (no las suposiciones) gu√≠en la arquitectura

El hecho de que puedas agregar combos ahora y escalar a grafos despu√©s **sin romper nada** es el sello de un dise√±o excelente.

---

**Siguiente Paso Recomendado:**
Usa la app durante 1-3 meses. Registra partidas, genera reportes b√°sicos. LUEGO decide si necesitas grafos. Probablemente descubras que el 80% de tu valor viene del MVP simple, y eso est√° perfectamente bien.
